# class Animal:
#     def speak(self):
#         # Метод, который может быть переопределён
#         print("Some generic animal sound")
#
# class Dog(Animal):
#     def speak(self):
#         print("Woof!")
#
# class Cat(Animal):
#     def speak(self):
#         print("Meow!")
#
# # Функция, которая вызывает метод speak — но не знает, кто перед ней
# def make_it_speak(animal: Animal):
#     # Здесь работает динамическое связывание:
#     # вызывается метод speak конкретного объекта
#     animal.speak()
#
# # Создаём объекты разных подклассов
# dog = Dog()
# cat = Cat()
#
# # Передаём их в одну и ту же функцию
# make_it_speak(dog)  # Выведет: Woof!
# make_it_speak(cat)  # Выведет: Meow!
#
#
# В момент написания кода компилятор/интерпретатор не знает, какой именно метод speak() будет вызван.
#
# Метод выбирается во время выполнения, в зависимости от фактического объекта (dog или cat).
#
# Это и есть динамическое связывание — ключевая черта полиморфизма в ООП.
#
