## Рефлексия Bloom Filter:
Здесь я все-таки решил сделать "двойной" контструктор. В остальном изначально было понятно и близко к предыдущей, не гибкой реализации.

## Эталонное решение:
```
abstract class BloomFilter<T>

  // конструктор
// постусловие: создан пустой фильтр Блюма заданного размера
  public BloomFilter<T> BloomFilter(int sz);

  // команды
// постусловие: в фильтр добавлено новое значение
  public void put(T value);

  // запросы
public bool is_value(T value);
  // содержится ли значение в фильтре
  // (допускаются ложноположительные срабатывания)
```

## Рефлексия Bounded Stack:
В целом мое решение соответсвует эталонному.

Я под реализацию добавил переменные статуса исполнения команд. Также я все-таки подумал что и для дополнительных запросов будет уместным добавить константу `PUSH_NIL = 0`, также символизирующую о том, что команда`push()` ещё не вызывалась (теоретически статус можно же запросить сразу после создания стека).

По предусловиям и постусловиям полное совпадение единственное - у меня два варианта, при этом основной все таки без параметров (подсмотрел идею единственного рабочего конструктора из книги Егора Бугаенко "Элегантные объекты").

В общем, по итогу, для меня это КРАЙНЕ необычный подход в проектировании классов. Обычно все это с аналтиками сумбурно как-то происходит, что ли.

Тт же подход основательный, меня до сих не покидает ощущение что я проектурю структуры для языка Си или что-т оподобное (вот эти вот статусы и т.п.). Но мне подход ОЧЕНЬ импонирует, буду вндрять его в свою коммерческую разработку.

## Эталонное решение:
```
abstract class BoundedStack<T>

    public const int POP_NIL = 0; // push() ещё не вызывалась
    public const int POP_OK = 1; // последняя pop() отработала нормально
    public const int POP_ERR = 2; // стек пуст

    public const int PEEK_NIL = 0; // push() ещё не вызывалась
    public const int PEEK_OK = 1; // последняя peek() вернула корректное значение
    public const int PEEK_ERR = 2; // стек пуст

    public const int PUSH_OK = 1; // последняя push() отработала нормально
    public const int PUSH_ERR = 2; // в стеке нет свободного места

    // конструктор
// постусловие: создан новый пустой стек
    public BoundedStack<T> BoundedStack(int max_size);


    // команды:
// предусловие: в стеке менее максимального кол-ва элементов
// постусловие: в стек добавлено новое значение
    public void push(T value);

// предусловие: стек не пустой;
// постусловие: из стека удалён верхний элемент
    public void pop();

// постусловие: из стека удалятся все значения
    public void clear();


    // запросы:
// предусловие: стек не пустой
    public T peek();

    public int size();
    public int max_size();

    // дополнительные запросы:
    public int get_pop_status(); // возвращает значение POP_*
    public int get_peek_status(); // возвращает значение PEEK_*
    public int get_push_status(); // возвращает значение PUSH_*
```

## Рефлексия Dynamic Array:
Cчитаю методы вставки справа и слева от индекса избыточными и потенциально вводящими в заблуждение пользователя класса. Всегда можно указать конкретный индекс. 
Возможно, это имеет смысл если мы нашли некоторое значение и хотим произвести вставку справа или слева от него, но мне кажется это несколько нелогичным. Хотя я и могу ошибаться, конечно. В остальном проектирование совпало с эталонным решением. 

## Эталонное решение:
```
abstract class DynArray<T>

  // конструктор
// постусловие: создан пустой массив
  public DynArray<T> DynArray();

  // команды
// предусловие: i лежит в допустимых границах массива; 
// постусловие: значение элемента i изменено на value
  public void put(i, T value);

// предусловие: i лежит в допустимых границах массива; 
// постусловие: перед элементом i добавлен 
// новый элемент с значением value; 
  public void put_left(i, T value);

// предусловие: i лежит в допустимых границах массива; 
// постусловие: после элемента i добавлен 
// новый элемент с значением value;
  public void put_right(i, T value);

// предусловие: нет; 
// постусловие: в хвост массива добавлен 
// новый элемент
  public void append(T value); 

// предусловие: i лежит в допустимых границах массива; 
// постусловие: элемент i удалён из массива;
  public void remove(int i); 

  // запросы 
// предусловие: i лежит в допустимых границах массива;
  public T get(int i); // значение i-го элемента 
  public int size(); // текущий размер массива 

  // запросы статусов (возможные значения статусов)
  public int get_put_status(); // успешно; индекс за пределами массива
  public int get_put_left_status(); // успешно; индекс за пределами массива
  public int get_put_right_status(); // успешно; индекс за пределами массива
  public int get_remove_status(); // успешно; индекс за пределами массива
  public int get_get_status(); // успешно; индекс за пределами массива
```

## Рефлексия HashTable:
В целом совпало, но я решил еще добавить статусов на запрос, имеется ли значение. Хотя согласен, что он избыточен, спокойно можно без него обойтись. Кстати, глянул на мою предыдущую реализацию и подумал: "Боже мой, кто это писал?" :)

## Эталонное решение:
```
abstract class HashTable<T>

  // конструктор
// постусловие: создана пустая хэш-таблица заданного размера
  public HashTable<T> HashTable(int sz); 

  // команды
// предусловие: в таблице имеется свободный слот для value;
// постусловие: в таблицу добавлено новое значение
  public void put(T value); 

// предусловие: в таблице имеется значение value;
// постусловие: из таблицы удалено значение value
  public void remove(T value); 

  // запросы
  public bool get(T value); // содержится ли значение value в таблице

  public int size(); // количество элементов в таблице

  // запросы статусов (возможные значения статусов)
  public int get_put_status(); // успешно; 
    // система коллизий не смогла найти свободный слот для значения

  public int get_remove_status(); // успешно; значения нету в таблице
```

## Рефлексия LinkedList:
По описанию предусловий и постусловий расхождений нет, это радует, значит я уловил основную суть проектирования. По прежнему страхуюсь дополнительными статусами и их запросами(remove_all), но правда теперь мне не кажется это таким ужасным. Наоборот, кажется я начинаю понимать истинный смысл статусов - не лодить исключений и неадекватного поведения, а просто сообщать итог команды без попытки попутно что-то ещё происвсти в рантайме. По сравнению с мейнстримом, например, на Java или Kotlin(ужасно развращающий на тяп-ляп код язык!) это выглядит "пенсией", но сейчас мне кажется гораздо более эффективным решением в плане защищённости системы от разработчика.

## Эталонное решение
```
abstract class LinkedList<T>

  // конструктор
// постусловие: создан новый пустой список
  public LinkedList<T> LinkedList();

  // команды
// предусловие: список не пуст; 
// постусловие: курсор установлен на первый узел в списке
  public void head(); 

// предусловие: список не пуст; 
// постусловие: курсор установлен на последний узел в списке
  public void tail(); 

// предусловие: правее курсора есть элемент; 
// постусловие: курсор сдвинут на один узел вправо
  public void right(); 

// предусловие: список не пуст; 
// постусловие: следом за текущим узлом добавлен 
// новый узел с заданным значением
  public void put_right(T value); 

// предусловие: список не пуст; 
// постусловие: перед текущим узлом добавлен 
// новый узел с заданным значением
  public void put_left(T value); 

 // предусловие: список не пуст; 
// постусловие: текущий узел удалён, 
// курсор смещён к правому соседу, если он есть, 
// в противном случае курсор смещён к левому соседу,
// если он есть
  public void remove();

// постусловие: список очищен от всех элементов
  public void clear(); 

// постусловие: новый узел добавлен в хвост списка
  public void add_tail(T value); 

// постусловие: в списке удалены все узлы с заданным значением
  public void remove_all(T value);

// предусловие: список не пуст;
// постусловие: значение текущего узла заменено на новое
  public void replace(T value); 

// постусловие: курсор установлен на следующий узел 
// с искомым значением, если такой узел найден
  public void find(T value); 

  // запросы
  public T get(); // предусловие: список не пуст
  public bool is_head();
  public bool is_tail();
  public bool is_value();
  public int size();

  // запросы статусов (возможные значения статусов)
  public int get_head_status(); // успешно; список пуст
  public int get_tail_status(); // успешно; список пуст
  public int get_right_status(); // успешно; правее нету элемента
  public int get_put_right_status(); // успешно; список пуст
  public int get_put_left_status(); // успешно; список пуст
  public int get_remove_status(); // успешно; список пуст
  public int get_replace_status(); // успешно; список пуст
  public int get_find_status(); // следующий найден; 
                       // следующий не найден; список пуст
  public int get_get_status(); // успешно; список пуст
```

## Рефлексия Native Dictionary:
Предусовия и постусловия прописал не так подробно (а значит не до конца сформулировал мысль, нужно поработать над этим), но в целом все совпало!
Неожиданно до меня дошло, что можно и нужно активно использовать Optional(конкретно для Java) или любую обертку над значением. В таком сучае даже при негативном сценарии нам не придется использовать костыль null или явно вызывать исключение, а можно сначала запрашивать статус выполнения команды и потом решать что делать. Странно что  на предыдущих классах до этого не додумался, а ведь мне кажется это настолько очевидным.

## Эталонное решение:
```
abstract class NativeDictionary<T>

  // конструктор
// постусловие: создан пустой ассоциативный массив
  public NativeDictionary<T> NativeDictionary();

  // команды
// постусловие: в массив добавлена новая пара ключ-значение, 
// если данный ключ отсутствовал;
// в противном случае обновлено значение
// для соответствующего ключа
  public void put(string key, T value);

// предусловие: ключ key присутствует в массиве
// постусловие: ключ удаляется вместе со своим значением
  public void remove(string key);

  // запросы
// предусловие: ключ key присутствует в массиве
  public T get(string key);

// данный запрос требуется отдельно, 
// чтобы не использовать вместо него
// второстепенный запрос проверки статуса запроса get
  public bool is_key(string key); // проверка наличия ключа в массиве

  public int size(); // текущий размер массива

  // запросы статусов (возможные значения статусов)
  public int get_put_status();
    // успешно добавлен новый ключ и значение; 
    // успешно обновлено значение существующего ключа

  public int get_remove_status(); // успешно; ключ отсутствует

  public int get_get_status(); // успешно; ключ отсутствует
```

## Рефлексия ParentList:
Ход проектирования был, в принципе, понятен. И напутать тут было бы сложно. Предусловия и постусловия совпали, что ожидаемо, поскольку было все разложено по полочкам на предыдущем занятии. По ощущениям, такой подход начал хорошо дисциплинировать. Переношу частично на рабочие процессы и результат нравится. Правда, в рабочих вариантах не использую статусы пока, коллеги не понимают.
Уже после реализации замети, что ни у меня, ни в эталонном решении как-будто бы нет вариантов корректной вставки элемента, надо будет с этим разобраться.

## Эталонное решение:
```
abstract class ParentList<T>

  // конструктор
  public ParentList<T> ParentList();

  // команды
  public void head(); 
  public void tail(); 
  public void right(); 
  public void put_right(T value); 
  public void put_left(T value); 
  public void remove();
  public void clear(); 
  public void add_tail(T value); 
  public void remove_all(T value);
  public void replace(T value); 
  public void find(T value); 

  // запросы
  public T get();
  public bool is_head();
  public bool is_tail();
  public bool is_value();
  public int size();

  // запросы статусов
  public int get_head_status();
  public int get_tail_status();
  public int get_right_status();
  public int get_put_right_status();
  public int get_put_left_status();
  public int get_remove_status();
  public int get_replace_status();
  public int get_find_status();
  public int get_get_status();

abstract class LinkedList<T> : ParentList<T>

  // конструктор
  public LinkedList<T> LinkedList();

abstract class TwoWayList<T> : ParentList<T>

  // конструктор
  public TwoWayList<T> TwoWayList();

// предусловие: левее курсора есть элемент; 
// постусловие: курсор сдвинут на один узел влево
  public void left();

  public int get_left_status(); // успешно; левее нету элемента
```

## Рефлексия ParentQueue:
Проектирование было сделано по аналогии со списками, поэтому сложностей не возникло и ответ получился крайне близок к эталонному. Вообще заметил, что в экосистеме Java это гораздо проще делать через интерфейсы, нежели через наследование. 

## Эталонное решение:
### АТД ParentQueue
```
abstract class ParentQueue<T>

  // конструктор
  public ParentQueue<T> ParentQueue();

  // команды
// постусловие: в хвост очереди добавлен новый элемент
  public void add_tail(T value);

// предусловие: очередь не пуста;
// постусловие: из головы очереди удалён элемент
  public void remove_front();

  // запросы
// предусловие: список не пуст
  public T get_front(); // значение элемента в голове очереди; 

  public int size(); // текущий размер очереди

  // запросы статусов (возможные значения статусов)
  public int get_remove_front_status(); // успешно; очередь пуста
  public int get_get_front_status(); // успешно; очередь пуста
```
### АТД Queue
```
abstract class Queue<T> : ParentQueue<T>

  // конструктор
  public Queue<T> Queue();
```
### АТД Deque
```
abstract class Deque<T> : ParentQueue<T>

  // конструктор
// постусловие: создана пустая очередь
  public Deque<T> Deque();

  // команды
// постусловие: в голову очереди добавлен новый элемент
  public void add_front(T value); 

// предусловие: очередь не пуста;
// постусловие: из хвоста очереди удалён элемент
  public void remove_tail(); 

  // запросы
// предусловие: список не пуст
  public T get_tail(); // значение элемента в хвосте очереди; 

  public int size(); // текущий размер очереди

  // запросы статусов (возможные значения статусов)
  public int get_remove_tail_status(); // успешно; очередь пуста
  public int get_get_tail_status(); // успешно; очередь пуста
```

## Рефлексия PowerSet
С дополнительными методаим и их реализацией (в том числе с операцией Union). Но вот насчет пред и постусловий я думал несколько иначе, мне не пришло в голову что это именно замыкание, я просто подумал что раз мы никак не модифицируем входные данные и нам в принципе все равно что у нас будет на входе (это я про пустое множество), а результат мы получим какой-либо в любом случае, то и пред и пост условий нам как-будто и не нужно вставлять.

И еще момент по реализации - сейчас уже мне кажется что конкретно Java заточена под реализацию интерфейсов. Интерфейс в Java вполне может выступать(а на проекте зачастую и выступает) в качестве абстрактного класса.

## Эталононе решение
```
abstract class PowerSet<T> : HashTable<T>

  // конструктор
// постусловие: создано пустое множество
// на максимальное количество элементов sz
  public PowerSet<T> PowerSet(int sz); 

  // запросы
// возвращает пересечение текущего множества
// с множеством set
  public PowerSet<T> Intersection(PowerSet<T> set);

// возвращает объединение текущего множества
// и множества set
  public PowerSet<T> Union(PowerSet<T> set);

// возвращает разницу между текущим множеством
// и множеством set
  public PowerSet<T> Difference(PowerSet<T> set);

// проверка, будет ли set подмножеством
// текущего множества
  public bool IsSubset(PowerSet<T> set);
```

## Рефлексия Queue:
Решение совпало, но оно и не удивительно, после проработанных АТД, подводных камней в этой структуре данных встретить не должен был.

## Эталонное решение:
```
abstract class Queue<T>

  // конструктор
// постусловие: создана пустая очередь
  public Queue<T> Queue();

  // команды
// постусловие: в хвост очереди добавлен новый элемент
  public void enqueue(T value);

// предусловие: очередь не пуста;
// постусловие: из головы очереди удалён элемент
  public void dequeue();

  // запросы
// предусловие: очередь не пуста
  public T get(); // получить элемент из головы очереди; 

  public int size(); // текущий размер очереди

  // запросы статусов (возможные значения статусов)
  public int get_dequeue_status(); // успешно; очередь пуста
  public int get_get_status(); // успешно; очередь пуста
``` 